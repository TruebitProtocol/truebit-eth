# emscripten module wrapper

This is a wrapper to collect information needed to run WebAssembly modules generated by emscripten.

The idea is that we should be able to run wasm module that use Wasi, and then post the results as a verified computation using TrueBit.
The script `prepare.js` uses the ocaml interpreter to generate a wasm file that has our runtime linked in.
Now this file can be ran using the ocaml off-chain interpreter.

## Installation instructions

Install npm dependencies. Node 16 required

```sh
npm install
```

Install wasienv for C/C++ or Rust:

For Rust:

```sh
rustup target add wasm32-wasi
```

For [wasienv](https://github.com/wasienv/wasienv):

```bash
curl https://raw.githubusercontent.com/wasienv/wasienv/master/install.sh | sh
```

The above should install wasienv to `~/.local/bin`

Note that the compiled programs will have to include the debug symbols, otherwise the Truebit WASI runtime cannot share
the memory with the actual program.

Follow installation instructions for the ocaml-offchain interpreter [here](https://github.com/TruebitProtocol/truebit-eth#running-truebit-os-natively)

If necessary edit `prepare.js` to include the correct path for wasm interpreter (default: `../ocaml-offchain/interpreter/wasm`).
Also edit the IPFS host.

## Usage

```sh
node prepare.js file.js
```

Options:

* `--file fname`: add the file to the IO block of the task
* `--arg arg`: add command line argument
* `--float`: add floating point emulation
* `--out`: the directory to store the results in, can be tmp if using ipfs.
* `--upload-ipfs`: upload to ipfs
* `--ipfs-host`: default is localhost
* `--rust`: use for Wasi files coming from Rust
* `--metering num`: add metering for the task
* `--stack-limit num`: limit the size of program stack
* `--memory-size num`: set the size of memory to 2^num 64-bit elements

A successful output will look like this:

```json
{
  "ipfshash": "QmaDMzoEE51eNJCc1dMsxUKQGp41qvCsgbv3PHhcbKbAKe",
  "codehash": "0xcc0d89e2f7ad0f720cdc6521ab698c1053dac534cd770fb6531d935975ee5d7e",
  "info": {
    "vm": {
      "code": "0xcc0d89e2f7ad0f720cdc6521ab698c1053dac534cd770fb6531d935975ee5d7e",
      "stack": "0xb4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30",
      "memory": "0xb4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30",
      "input_size": "0x593e5b969fbeac1646d534f40aeeb6d440f1b60353267ff7a67bb53a3a8f1125",
      "input_name": "0x9f9a605ee9da9ebd0f0a58d289c2345d279c3e11baafdefe72bb5aa2ead36e38",
      "input_data": "0x066ccee69369f2589250d208feef82cd3e06356124c01b9e9e8d56c9393e0e85",
      "call_stack": "0xb4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30",
      "globals": "0xb4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30",
      "calltable": "0x7bf9aa8e0ce11d87877e8b7a304e8e7105531771dbff77d1b00366ecb1549624",
      "calltypes": "0xb4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30",
      "pc": 0,
      "stack_ptr": 0,
      "call_ptr": 0,
      "memsize": 0
    },
    "hash": "0x9e10c72398fc17ba4fa0163ea8da8d1401abfe4ef93335b122df18498cac5da7"
  },
  "memsize": "25"
}
```

## Different passes applied to program

1. Figure out which function is malloc.
2. The wasi prefixes `wasi_unstable`  and `wasi_snapshot_preview1` are allowed
3. In case the `--rust` option was not given, replace bulk memory instructions with loops
4. Merge the program with `filesystem.wasm`. This will link the wasi calls to functions in `filesystem.wasm`
5. Add underscores to symbol names. After this phase we should have the wasm file that can be sent to Truebit network
6. Add metering
7. Add limiting the stack

Note that adding metering and limiting the stack will have to be done by the participants to make sure
that the program execution terminates and there are no non-deterministic errors due to stack overflow.
